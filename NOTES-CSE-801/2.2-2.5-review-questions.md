# Sections 2.2–2.5 Review Questions: HTTP, E-mail, DNS, and P2P

This document provides detailed answers to the review questions for Sections 2.2–2.5, based on the context from "Computer Networking: A Top-Down Approach."

---

### **R10. What is meant by a handshaking protocol?**

A **handshaking protocol** is a procedure where two communicating entities exchange control information or introductory messages before any application-layer data is sent. This process allows the client and server to agree on parameters for communication and to prepare for the exchange of data.

A classic example is the **TCP three-way handshake**, which establishes a connection. In application-layer protocols like SMTP, handshaking is used for introductions (e.g., the `HELO` command) before the mail message is transferred.

![Handshaking Protocol](../supplies/images/handshaking-protocol.png)

---

### **R11. Why do HTTP, SMTP, and IMAP run on top of TCP rather than on UDP?**

HTTP (for web browsing), SMTP (for sending e-mail), and IMAP (for retrieving e-mail) all run on top of TCP because they require **reliable data transfer**.

-   **HTTP:** When you download a web page, every part of the HTML file, every image, and every script must arrive completely and without errors. If data were lost, the page would be broken or incomplete.
-   **SMTP & IMAP:** For e-mail, it is critical that the message arrives exactly as it was sent, without any missing or corrupted words or attachments.

**TCP** provides this reliability by guaranteeing that all data sent from one end of the connection will arrive without error and in the proper order at the other end. **UDP**, on the other hand, is unreliable and provides no such guarantees, making it unsuitable for these applications.

---

### **R12. Consider an e-commerce site that wants to keep a purchase record for each of its customers. Describe how this can be done with cookies.**

An e-commerce site can use cookies to track a customer's activity and maintain a purchase record, even though HTTP itself is stateless. Here's how:

1.  **First Visit:** When a customer first visits the site, the server creates a unique identification number (e.g., `1678`) for them. It creates an entry in its back-end database indexed by this ID.
2.  **Set-Cookie Response:** The server sends an HTTP response to the customer's browser that includes a `Set-Cookie: 1678` header.
3.  **Browser Stores Cookie:** The customer's browser receives this response and stores the cookie (the hostname `amazon.com` and the ID `1678`) in a local file.
4.  **Subsequent Visits:** On every subsequent request to that same e-commerce site, the browser automatically includes a `Cookie: 1678` header.
5.  **Server Identification:** When the server receives a request with this cookie, it uses the ID `1678` to look up the customer's record in its database.
6.  **Tracking Purchases:** When the customer adds an item to their cart or makes a purchase, the server records this action in the database entry associated with ID `1678`.

This allows the server to maintain a persistent shopping cart and a complete history of all purchases made by that user across multiple sessions.

---

### **R13. Describe how Web caching can reduce the delay in receiving a requested object. Will Web caching reduce the delay for all objects requested by a user or for only some of the objects? Why?**

A **Web cache** (or proxy server) is a network entity that stores copies of recently requested web objects. It reduces delay in two main ways:

1.  **Reduces Response Time:** If the cache is geographically or topologically closer to the client than the origin server, it can deliver a stored object much faster. For example, a cache on a university's local network can serve an object almost instantaneously compared to fetching it from a server across the country.
2.  **Reduces Network Congestion:** By satisfying requests locally, the cache reduces the amount of traffic on the institution's access link to the Internet. This lowers the traffic intensity and significantly decreases queuing delays at the bottleneck link for objects that must be fetched from the origin.

Web caching will **only reduce the delay for some objects**.

-   **Cached Objects (Hits):** If an object is already in the cache, the delay is significantly reduced.
-   **Uncached Objects (Misses):** If an object is not in the cache (i.e., it's the first time it's being requested), the cache must first fetch it from the origin server. This adds a small amount of overhead, so the delay for the first request of an object is not reduced; it might even be slightly longer. However, all subsequent requests for that object will be fast.

---

### **R14. Telnet into a Web server and send a multiline request message. Include in the request message the If-modified-since: header line to force a response message with the 304 Not Modified status code.**

To perform this, you would use the `telnet` command to connect to a web server on port 80 and manually type an HTTP GET request.

**Steps:**

1.  **First Request (to get the `Last-Modified` date):**
    ```bash
    telnet gaia.cs.umass.edu 80
    GET /kurose_ross/interactive/index.php HTTP/1.1
    Host: gaia.cs.umass.edu
    [Press Enter twice]
    ```
    The server would respond with a `200 OK` message and the object. In the headers, you would find a line like:
    `Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT`

2.  **Second Request (Conditional GET):**
    Now, make a second request using that date in the `If-Modified-Since` header.
    ```bash
    telnet gaia.cs.umass.edu 80
    GET /kurose_ross/interactive/index.php HTTP/1.1
    Host: gaia.cs.umass.edu
    If-Modified-Since: Tue, 18 Aug 2015 15:11:03 GMT
    [Press Enter twice]
    ```

**Expected Response:**
Since the object has not been modified since that date, the server will return:
```
HTTP/1.1 304 Not Modified
Date: [Current Date]
...
(empty entity body)
```
This `304 Not Modified` response tells the client (or cache) that its cached version is still valid and can be used, saving the bandwidth of re-downloading the object.

---

### **R15. List several popular messaging apps. Do they use the same protocols as SMS?**

-   **Popular Messaging Apps:** WhatsApp, Facebook Messenger, WeChat, Telegram, Signal.
-   **Do they use the same protocols as SMS?** **No.**

**Differences:**
-   **SMS (Short Message Service)** operates on the cellular network's signaling channels and does not require the Internet. It uses protocols from the SS7 suite.
-   **Modern Messaging Apps** are "over-the-top" (OTT) applications that run over the Internet. They use standard Internet protocols like **TCP/IP** and often proprietary application-layer protocols for the messaging itself. For example, WhatsApp is based on a modified version of XMPP.

---

### **R16. Suppose Alice, with a Web-based e-mail account (such as Gmail), sends a message to Bob, who accesses his mail from his mail server using IMAP. Discuss how the message gets from Alice's host to Bob's host.**

Here is the sequence of protocols used:

1.  **Alice's User Agent to Her Mail Server:** Alice composes her e-mail in a web browser. When she clicks "Send," her browser sends the message to her mail server (e.g., Gmail's server) using **HTTP**.
2.  **Alice's Mail Server to Bob's Mail Server:** Alice's mail server (now acting as an SMTP client) opens a TCP connection to Bob's mail server on port 25. The e-mail message is then transferred between the two servers using **SMTP**.
3.  **Bob's Mail Server to His User Agent:** The message is now in Bob's mailbox on his mail server. When Bob opens his mail client (e.g., Outlook), his client retrieves the message from the server using **IMAP (Internet Mail Access Protocol)**.

**Protocol Chain:** `HTTP` → `SMTP` → `IMAP`

![Email Protocol Chain](../supplies/images/email-protocol-chain.png)

---

### **R17. Print out the header of an e-mail message you have recently received. How many Received: header lines are there? Analyze each of the header lines in the message.**

*(This answer is illustrative, as I cannot access personal e-mails. A typical header analysis would look like this.)*

**Sample Header:**
```
Received: from mail-sorter.google.com (mail-sorter.google.com [209.85.220.6])
    by my-mail-server.com with ESMTP id 12345;
    Fri, 7 Nov 2025 10:00:00 -0500
Received: by mail-ot1-f69.google.com with SMTP id f69so1234567otb.1
    for <recipient@example.com>; Fri, 07 Nov 2025 07:00:00 -0800 (PST)
From: "Sender Name" <sender@example.com>
To: "Recipient Name" <recipient@example.com>
Subject: Example Subject
Date: Fri, 7 Nov 2025 15:00:00 +0000
Message-ID: <xyz@mail.gmail.com>
```

-   **`Received:` Headers:** There are **two** `Received:` headers in this example. These headers trace the path the e-mail took. You read them from bottom to top.
    -   The bottom `Received:` line shows the message was received by Google's server `mail-ot1-f69.google.com`.
    -   The top `Received:` line shows it was then passed from Google's `mail-sorter` to `my-mail-server.com`. Each `Received` line is added by the mail server that receives the message.
-   **`From:`, `To:`, `Subject:`, `Date:`:** These are part of the message itself and are displayed to the end-user. They can be easily forged.
-   **`Message-ID:`:** A unique identifier for the message, generated by the original sending mail client or server.

---

### **R18. What is the HOL blocking issue in HTTP/1.1? How does HTTP/2 attempt to solve it?**

-   **Head-of-Line (HOL) Blocking in HTTP/1.1:** Even with persistent connections, if multiple objects are requested over a single TCP connection, they are served in a strict first-come, first-served (FCFS) order. If a large object (like a video) is requested first, followed by several small objects (like icons), the small objects are "blocked" and must wait for the entire large object to be transferred first. This increases the perceived load time of the page.

-   **HTTP/2 Solution:** HTTP/2 solves this by breaking messages into smaller, independent **frames**. It can then **interleave** these frames on the single TCP connection. For example, it can send a frame from the large video, then a frame from a small image, then another frame from the video, and so on. This allows the smaller objects to be completed and rendered much faster, without having to wait for the large object to finish, thus mitigating HOL blocking.

---

### **R19. Is it possible for an organization's Web server and mail server to have exactly the same alias for a hostname (for example, foo.com)? What would be the type for the RR that contains the hostname of the mail server?**

-   **Is it possible?** **Yes.** An organization can use the same alias (e.g., `mycompany.com`) for both its web server and its mail server.
-   **How?** This is achieved using different types of DNS resource records (RRs).
    -   A client wanting to connect to the web server would query for a **Type A** (or AAAA) record to get the IP address.
    -   A mail server wanting to send e-mail would query for a **Type MX (Mail Exchange)** record.
-   **What is the RR type for the mail server?** The **MX record** is used to specify the mail server. The MX record for `mycompany.com` would point to the canonical hostname of the mail server (e.g., `mail.mycompany.com`), which in turn would have its own A record.

---

### **R20. Look over your received e-mails, and examine the header of a message sent from a user with a .edu e-mail address. Is it possible to determine from the header the IP address of the host from which the message was sent? Do the same for a message sent from a Gmail account.**

-   **.edu e-mail address:** **Often, yes.** E-mails sent from smaller institutional networks (like a university) often have `Received:` headers that show the IP address of the user's desktop machine or the department's mail server where the message originated.

-   **Gmail account:** **Usually, no.** When an e-mail is sent through a large web-based provider like Gmail, the original client's IP address is typically stripped from the headers for privacy. The `Received:` headers will only show the IP addresses of Google's internal mail servers, not the IP address of the user who sent the e-mail.

---

### **R21. In BitTorrent, suppose Alice provides chunks to Bob throughout a 30-second interval. Will Bob necessarily return the favor and provide chunks to Alice in this same interval? Why or why not?**

**Not necessarily.**

Bob will only provide chunks to Alice if Alice is one of his **top four uploaders**. BitTorrent's "tit-for-tat" mechanism dictates that peers prioritize sending data to the four other peers who are providing them with data at the highest rate.

-   If Alice is sending chunks to Bob at a high enough rate to be in his top four, then Bob will reciprocate.
-   If Alice is not in his top four, Bob will "choke" her (not send her data), unless she is chosen as Bob's "optimistically unchoked" peer, which happens randomly to one peer every 30 seconds.

So, reciprocation is based on performance, not just on the fact that a transfer is happening.

---

### **R22. Consider a new peer Alice that joins BitTorrent without possessing any chunks. Without any chunks, she cannot become a top-four uploader for any of the other peers, since she has nothing to upload. How then will Alice get her first chunk?**

Alice will get her first chunk through the **optimistic unchoking** mechanism.

Every 30 seconds, each peer in the torrent randomly selects one other peer to send chunks to, regardless of that peer's current upload rate. This gives new peers like Alice, who have nothing to trade yet, a chance to receive their first few chunks. Once she has some chunks, she can begin to upload them to others, participate in the "tit-for-tat" trading, and work her way into the top-four lists of other peers to increase her download rate.

---

### **R23. What is an overlay network? Does it include routers? What are the edges in the overlay network?**

-   **What is an overlay network?** An overlay network is a virtual or logical network built on top of an existing physical network (the "underlay" network, which is the Internet itself). In a P2P overlay network, the peers form nodes, and the logical connections between them form the edges.

-   **Does it include routers?** **No.** The routers in the underlying physical network are not part of the overlay network. The overlay consists only of the participating peers and the logical links between them. The fact that a logical link between two peers might pass through dozens of physical routers is hidden from the overlay.

-   **What are the edges in the overlay network?** The edges are the **logical connections** between pairs of peers. In many P2P systems, this is an active **TCP connection**. For example, in a BitTorrent torrent, the set of peers that Alice is connected to are her neighbors, and the TCP connections to them are the edges of the overlay network from her perspective.