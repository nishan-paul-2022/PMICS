# Section 2.7 Review Questions: Socket Programming

This document provides detailed answers to the review questions for Section 2.7, based on the context from "Computer Networking: A Top-Down Approach."

---

### **R26. In Section 2.7, the UDP server described needed only one socket, whereas the TCP server needed two sockets. Why? If the TCP server were to support n simultaneous connections, each from a different client host, how many sockets would the TCP server need?**

#### Why UDP Needs One Socket vs. TCP Needing Two

**UDP Server (One Socket):**
The UDP server needs only one socket. This single socket is used to receive all incoming datagrams from any client. When the server receives a datagram, the operating system includes the client's source IP address and port number. The server uses this source address to send its reply back to the correct client. The same socket is used to communicate with all clients; it simply sends replies to different addresses based on where the incoming packets originated.

**TCP Server (Two Types of Sockets):**
The TCP server requires two types of sockets because it is connection-oriented.

1.  **Welcoming Socket (Listening Socket):** The server first creates a single "welcoming" socket that is bound to a well-known port (e.g., port 12000). This socket's job is to listen for connection requests from new clients. It does not handle data transfer for established connections.

2.  **Connection Socket:** When a client initiates a connection (knocks on the welcoming door), the server's welcoming socket accepts the connection and creates a **brand-new socket** specifically for that client. This new "connection socket" is dedicated to all communication with that particular client. The original welcoming socket then goes back to listening for new connection requests from other clients.

This model allows a TCP server to handle multiple clients simultaneously, each with its own dedicated connection socket, while the welcoming socket remains free to accept new clients.

![TCP Server Sockets](../notes/images/tcp-server-sockets.png)

#### Sockets Needed for `n` Simultaneous TCP Connections

If a TCP server were to support `n` simultaneous connections, it would need **`n + 1`** sockets.

-   **1 Welcoming Socket:** To listen for and accept new connection requests.
-   **`n` Connection Sockets:** One dedicated connection socket for each of the `n` active clients.

---

### **R27. For the client-server application over TCP described in Section 2.7, why must the server program be executed before the client program? For the client-server application over UDP, why may the client program be executed before the server program?**

#### TCP: Server Must Run First

The TCP server program must be executed before the client program because TCP is **connection-oriented**.

1.  The server must first create its "welcoming socket" and bind it to a specific port.
2.  It then calls `listen()` on this socket to begin actively listening for connection requests.
3.  Only when the server is in this `LISTEN` state can a client successfully complete the three-way handshake to establish a connection.

If the client tries to connect before the server is running and listening, the server's operating system will have no process to hand the connection request to and will reject the connection (typically with a `RST` packet), causing a "Connection Refused" error on the client side.

#### UDP: Client May Run First

The UDP client program may be executed before the server program because UDP is **connectionless**.

1.  The UDP client does not establish a connection. It simply creates a datagram (packet) with the server's destination address and sends it.
2.  The `sendto()` operation on the client side will succeed immediately, sending the packet out into the network. The client's OS does not verify if a server is actually listening at the destination.
3.  The packet will travel to the server's host. If the server process isn't running, the host's OS will see that no process is bound to the destination port and will likely drop the packet (and may send back an ICMP "Port Unreachable" message, which the client often ignores).
4.  The client program will then typically call `recvfrom()` and block, waiting for a reply that will never come.

So, while the client program "runs," it won't successfully complete its task, but it will not crash with an immediate error like the TCP client would. It will simply wait indefinitely for a response.